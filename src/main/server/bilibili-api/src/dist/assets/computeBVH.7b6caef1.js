var pe=Object.defineProperty,de=Object.defineProperties;var he=Object.getOwnPropertyDescriptors;var qt=Object.getOwnPropertySymbols;var ye=Object.prototype.hasOwnProperty,xe=Object.prototype.propertyIsEnumerable;var Nt=(n,t,e)=>t in n?pe(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,ft=(n,t)=>{for(var e in t||(t={}))ye.call(t,e)&&Nt(n,e,t[e]);if(qt)for(var e of qt(t))xe.call(t,e)&&Nt(n,e,t[e]);return n},Ht=(n,t)=>de(n,he(t));import{V as F,i as at,J as re,bf as O,b4 as Y,M as gt,H as Pt,b3 as Ot,at as me,L as we,a as Ae,c as be,bg as Ct,b5 as ge,O as Pe,b as Te,bh as Be,D as Me,bi as Se}from"./index.326876e1.js";const ce=0,ve=1,Ie=2,kt=2,Mt=1.25,jt=1,At=6*4+4+4,Vt=65535,Fe=Math.pow(2,-24);class ut{constructor(){}}function _(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function Xt(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function Wt(n,t){t.set(n)}function Gt(n,t,e){let s,i;for(let r=0;r<3;r++){const o=r+3;s=n[r],i=t[r],e[r]=s<i?s:i,s=n[o],i=t[o],e[o]=s>i?s:i}}function pt(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],r=t[n+2*s+1],o=i-r,l=i+r;o<e[s]&&(e[s]=o),l>e[s+3]&&(e[s+3]=l)}}function et(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}function Ce(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;e>65535?i=new Uint32Array(new s(4*e)):i=new Uint16Array(new s(2*e)),n.setIndex(new Pt(i,1));for(let r=0;r<e;r++)i[r]=r}}function Ve(n){if(!n.groups||!n.groups.length)return[{offset:0,count:n.index.count/3}];const t=[],e=new Set;for(const i of n.groups)e.add(i.start),e.add(i.start+i.count);const s=Array.from(e.values()).sort((i,r)=>i-r);for(let i=0;i<s.length-1;i++){const r=s[i],o=s[i+1];t.push({offset:r/3,count:(o-r)/3})}return t}function St(n,t,e,s,i=null){let r=1/0,o=1/0,l=1/0,c=-1/0,f=-1/0,a=-1/0,u=1/0,p=1/0,d=1/0,b=-1/0,w=-1/0,A=-1/0;const y=i!==null;for(let x=t*6,h=(t+e)*6;x<h;x+=6){const m=n[x+0],g=n[x+1],P=m-g,M=m+g;P<r&&(r=P),M>c&&(c=M),y&&m<u&&(u=m),y&&m>b&&(b=m);const B=n[x+2],T=n[x+3],S=B-T,v=B+T;S<o&&(o=S),v>f&&(f=v),y&&B<p&&(p=B),y&&B>w&&(w=B);const I=n[x+4],C=n[x+5],L=I-C,V=I+C;L<l&&(l=L),V>a&&(a=V),y&&I<d&&(d=I),y&&I>A&&(A=I)}s[0]=r,s[1]=o,s[2]=l,s[3]=c,s[4]=f,s[5]=a,y&&(i[0]=u,i[1]=p,i[2]=d,i[3]=b,i[4]=w,i[5]=A)}function ze(n,t,e,s){let i=1/0,r=1/0,o=1/0,l=-1/0,c=-1/0,f=-1/0;for(let a=t*6,u=(t+e)*6;a<u;a+=6){const p=n[a+0];p<i&&(i=p),p>l&&(l=p);const d=n[a+2];d<r&&(r=d),d>c&&(c=d);const b=n[a+4];b<o&&(o=b),b>f&&(f=b)}s[0]=i,s[1]=r,s[2]=o,s[3]=l,s[4]=c,s[5]=f}function Le(n,t,e,s,i){let r=e,o=e+s-1;const l=i.pos,c=i.axis*2;for(;;){for(;r<=o&&t[r*6+c]<l;)r++;for(;r<=o&&t[o*6+c]>=l;)o--;if(r<o){for(let f=0;f<3;f++){let a=n[r*3+f];n[r*3+f]=n[o*3+f],n[o*3+f]=a;let u=t[r*6+f*2+0];t[r*6+f*2+0]=t[o*6+f*2+0],t[o*6+f*2+0]=u;let p=t[r*6+f*2+1];t[r*6+f*2+1]=t[o*6+f*2+1],t[o*6+f*2+1]=p}r++,o--}else return r}}const H=32,Ue=(n,t)=>n.candidate-t.candidate,j=new Array(H).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),dt=new Float32Array(6);function Ee(n,t,e,s,i,r){let o=-1,l=0;if(r===ce)o=Xt(t),o!==-1&&(l=(t[o]+t[o+3])/2);else if(r===ve)o=Xt(n),o!==-1&&(l=_e(e,s,i,o));else if(r===Ie){const c=et(n);let f=Mt*i;const a=s*6,u=(s+i)*6;for(let p=0;p<3;p++){const d=t[p],A=(t[p+3]-d)/H;if(i<H/4){const y=[...j];y.length=i;let x=0;for(let m=a;m<u;m+=6,x++){const g=y[x];g.candidate=e[m+2*p],g.count=0;const{bounds:P,leftCacheBounds:M,rightCacheBounds:B}=g;for(let T=0;T<3;T++)B[T]=1/0,B[T+3]=-1/0,M[T]=1/0,M[T+3]=-1/0,P[T]=1/0,P[T+3]=-1/0;pt(m,e,P)}y.sort(Ue);let h=i;for(let m=0;m<h;m++){const g=y[m];for(;m+1<h&&y[m+1].candidate===g.candidate;)y.splice(m+1,1),h--}for(let m=a;m<u;m+=6){const g=e[m+2*p];for(let P=0;P<h;P++){const M=y[P];g>=M.candidate?pt(m,e,M.rightCacheBounds):(pt(m,e,M.leftCacheBounds),M.count++)}}for(let m=0;m<h;m++){const g=y[m],P=g.count,M=i-g.count,B=g.leftCacheBounds,T=g.rightCacheBounds;let S=0;P!==0&&(S=et(B)/c);let v=0;M!==0&&(v=et(T)/c);const I=jt+Mt*(S*P+v*M);I<f&&(o=p,f=I,l=g.candidate)}}else{for(let h=0;h<H;h++){const m=j[h];m.count=0,m.candidate=d+A+h*A;const g=m.bounds;for(let P=0;P<3;P++)g[P]=1/0,g[P+3]=-1/0}for(let h=a;h<u;h+=6){let P=~~((e[h+2*p]-d)/A);P>=H&&(P=H-1);const M=j[P];M.count++,pt(h,e,M.bounds)}const y=j[H-1];Wt(y.bounds,y.rightCacheBounds);for(let h=H-2;h>=0;h--){const m=j[h],g=j[h+1];Gt(m.bounds,g.rightCacheBounds,m.rightCacheBounds)}let x=0;for(let h=0;h<H-1;h++){const m=j[h],g=m.count,P=m.bounds,B=j[h+1].rightCacheBounds;g!==0&&(x===0?Wt(P,dt):Gt(P,dt,dt)),x+=g;let T=0,S=0;x!==0&&(T=et(dt)/c);const v=i-x;v!==0&&(S=et(B)/c);const I=jt+Mt*(T*x+S*v);I<f&&(o=p,f=I,l=m.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:l}}function _e(n,t,e,s){let i=0;for(let r=t,o=t+e;r<o;r++)i+=n[r*6+s*2];return i/e}function De(n,t){const e=n.attributes.position,s=e.array,i=n.index.array,r=i.length/3,o=new Float32Array(r*6),l=e.offset||0;let c=3;e.isInterleavedBufferAttribute&&(c=e.data.stride);for(let f=0;f<r;f++){const a=f*3,u=f*6,p=i[a+0]*c+l,d=i[a+1]*c+l,b=i[a+2]*c+l;for(let w=0;w<3;w++){const A=s[p+w],y=s[d+w],x=s[b+w];let h=A;y<h&&(h=y),x<h&&(h=x);let m=A;y>m&&(m=y),x>m&&(m=x);const g=(m-h)/2,P=w*2;o[u+P+0]=h+g,o[u+P+1]=g+(Math.abs(h)+g)*Fe,h<t[w]&&(t[w]=h),m>t[w+3]&&(t[w+3]=m)}}return o}function Re(n,t){function e(y){p&&p(y/d)}function s(y,x,h,m=null,g=0){if(!b&&g>=c&&(b=!0,f&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(n))),h<=a||g>=c)return e(x),y.offset=x,y.count=h,y;const P=Ee(y.boundingData,m,o,x,h,u);if(P.axis===-1)return e(x),y.offset=x,y.count=h,y;const M=Le(l,o,x,h,P);if(M===x||M===x+h)e(x),y.offset=x,y.count=h;else{y.splitAxis=P.axis;const B=new ut,T=x,S=M-x;y.left=B,B.boundingData=new Float32Array(6),St(o,T,S,B.boundingData,r),s(B,T,S,r,g+1);const v=new ut,I=M,C=h-S;y.right=v,v.boundingData=new Float32Array(6),St(o,I,C,v.boundingData,r),s(v,I,C,r,g+1)}return y}Ce(n,t);const i=new Float32Array(6),r=new Float32Array(6),o=De(n,i),l=n.index.array,c=t.maxDepth,f=t.verbose,a=t.maxLeafTris,u=t.strategy,p=t.onProgress,d=n.index.count/3;let b=!1;const w=[],A=Ve(n);if(A.length===1){const y=A[0],x=new ut;x.boundingData=i,ze(o,y.offset,y.count,r),s(x,y.offset,y.count,r),w.push(x)}else for(let y of A){const x=new ut;x.boundingData=new Float32Array(6),St(o,y.offset,y.count,x.boundingData,r),s(x,y.offset,y.count,r),w.push(x)}return w}function qe(n,t){const e=Re(n,t);let s,i,r;const o=[],l=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let a=0;a<e.length;a++){const u=e[a];let p=c(u);const d=new l(At*p);s=new Float32Array(d),i=new Uint32Array(d),r=new Uint16Array(d),f(0,u),o.push(d)}return o;function c(a){return a.count?1:1+c(a.left)+c(a.right)}function f(a,u){const p=a/4,d=a/2,b=!!u.count,w=u.boundingData;for(let A=0;A<6;A++)s[p+A]=w[A];if(b){const A=u.offset,y=u.count;return i[p+6]=A,r[d+14]=y,r[d+15]=Vt,a+At}else{const A=u.left,y=u.right,x=u.splitAxis;let h;if(h=f(a+At,A),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return i[p+6]=h/4,h=f(h,y),i[p+7]=x,h}}}class q{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let r=0,o=t.length;r<o;r++){const c=t[r][e];s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let r=0,o=e.length;r<o;r++){const l=e[r],c=t.dot(l);s=c<s?c:s,i=c>i?c:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}q.prototype.setFromBox=function(){const n=new F;return function(e,s){const i=s.min,r=s.max;let o=1/0,l=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let a=0;a<=1;a++){n.x=i.x*c+r.x*(1-c),n.y=i.y*f+r.y*(1-f),n.z=i.z*a+r.z*(1-a);const u=e.dot(n);o=Math.min(u,o),l=Math.max(u,l)}this.min=o,this.max=l}}();(function(){const n=new q;return function(e,s){const i=e.points,r=e.satAxes,o=e.satBounds,l=s.points,c=s.satAxes,f=s.satBounds;for(let a=0;a<3;a++){const u=o[a],p=r[a];if(n.setFromPoints(p,l),u.isSeparated(n))return!1}for(let a=0;a<3;a++){const u=f[a],p=c[a];if(n.setFromPoints(p,i),u.isSeparated(n))return!1}}})();const Ne=function(){const n=new F,t=new F,e=new F;return function(i,r,o){const l=i.start,c=n,f=r.start,a=t;e.subVectors(l,f),n.subVectors(i.end,r.start),t.subVectors(r.end,r.start);const u=e.dot(a),p=a.dot(c),d=a.dot(a),b=e.dot(c),A=c.dot(c)*d-p*p;let y,x;A!==0?y=(u*p-b*d)/A:y=0,x=(u+y*p)/d,o.x=y,o.y=x}}(),Et=function(){const n=new at,t=new F,e=new F;return function(i,r,o,l){Ne(i,r,n);let c=n.x,f=n.y;if(c>=0&&c<=1&&f>=0&&f<=1){i.at(c,o),r.at(f,l);return}else if(c>=0&&c<=1){f<0?r.at(0,l):r.at(1,l),i.closestPointToPoint(l,!0,o);return}else if(f>=0&&f<=1){c<0?i.at(0,o):i.at(1,o),r.closestPointToPoint(o,!0,l);return}else{let a;c<0?a=i.start:a=i.end;let u;f<0?u=r.start:u=r.end;const p=t,d=e;if(i.closestPointToPoint(u,!0,t),r.closestPointToPoint(a,!0,e),p.distanceToSquared(u)<=d.distanceToSquared(a)){o.copy(p),l.copy(u);return}else{o.copy(a),l.copy(d);return}}}}(),He=function(){const n=new F,t=new F,e=new re,s=new O;return function(r,o){const{radius:l,center:c}=r,{a:f,b:a,c:u}=o;if(s.start=f,s.end=a,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l||(s.start=f,s.end=u,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l)||(s.start=a,s.end=u,s.closestPointToPoint(c,!0,n).distanceTo(c)<=l))return!0;const w=o.getPlane(e);if(Math.abs(w.distanceToPoint(c))<=l){const y=w.projectPoint(c,t);if(o.containsPoint(y))return!0}return!1}}();class k extends Ct{constructor(...t){super(...t),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new F),this.satBounds=new Array(4).fill().map(()=>new q),this.points=[this.a,this.b,this.c],this.sphere=new ge,this.plane=new re,this.needsUpdate=!1}intersectsSphere(t){return He(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,r=this.satAxes,o=this.satBounds,l=r[0],c=o[0];this.getNormal(l),c.setFromPoints(l,i);const f=r[1],a=o[1];f.subVectors(t,e),a.setFromPoints(f,i);const u=r[2],p=o[2];u.subVectors(e,s),p.setFromPoints(u,i);const d=r[3],b=o[3];d.subVectors(s,t),b.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,t),this.needsUpdate=!1}}k.prototype.closestPointToSegment=function(){const n=new F,t=new F,e=new O;return function(i,r=null,o=null){const{start:l,end:c}=i,f=this.points;let a,u=1/0;for(let p=0;p<3;p++){const d=(p+1)%3;e.start.copy(f[p]),e.end.copy(f[d]),Et(e,i,n,t),a=n.distanceToSquared(t),a<u&&(u=a,r&&r.copy(n),o&&o.copy(t))}return this.closestPointToPoint(l,n),a=l.distanceToSquared(n),a<u&&(u=a,r&&r.copy(n),o&&o.copy(l)),this.closestPointToPoint(c,n),a=c.distanceToSquared(n),a<u&&(u=a,r&&r.copy(n),o&&o.copy(c)),Math.sqrt(u)}}();k.prototype.intersectsTriangle=function(){const n=new k,t=new Array(3),e=new Array(3),s=new q,i=new q,r=new F,o=new F,l=new F,c=new F,f=new O,a=new O,u=new O;return function(d,b=null){this.needsUpdate&&this.update(),d.isSeparatingAxisTriangle?d.needsUpdate&&d.update():(n.copy(d),n.update(),d=n);const w=this.satBounds,A=this.satAxes;e[0]=d.a,e[1]=d.b,e[2]=d.c;for(let h=0;h<4;h++){const m=w[h],g=A[h];if(s.setFromPoints(g,e),m.isSeparated(s))return!1}const y=d.satBounds,x=d.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let h=0;h<4;h++){const m=y[h],g=x[h];if(s.setFromPoints(g,t),m.isSeparated(s))return!1}for(let h=0;h<4;h++){const m=A[h];for(let g=0;g<4;g++){const P=x[g];if(r.crossVectors(m,P),s.setFromPoints(r,t),i.setFromPoints(r,e),s.isSeparated(i))return!1}}if(b){const h=this.plane,m=d.plane;if(Math.abs(h.normal.dot(m.normal))>1-1e-10)console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),b.start.set(0,0,0),b.end.set(0,0,0);else{const g=this.points;let P=!1;for(let T=0;T<3;T++){const S=g[T],v=g[(T+1)%3];if(f.start.copy(S),f.end.copy(v),m.intersectLine(f,P?a.start:a.end)){if(P)break;P=!0}}const M=d.points;let B=!1;for(let T=0;T<3;T++){const S=M[T],v=M[(T+1)%3];if(f.start.copy(S),f.end.copy(v),h.intersectLine(f,B?u.start:u.end)){if(B)break;B=!0}}if(a.delta(o),u.delta(l),o.dot(l)<0){let T=u.start;u.start=u.end,u.end=T}c.subVectors(a.start,u.start),c.dot(o)>0?b.start.copy(a.start):b.start.copy(u.start),c.subVectors(a.end,u.end),c.dot(o)<0?b.end.copy(a.end):b.end.copy(u.end)}}return!0}}();k.prototype.distanceToPoint=function(){const n=new F;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();k.prototype.distanceToTriangle=function(){const n=new F,t=new F,e=["a","b","c"],s=new O,i=new O;return function(o,l=null,c=null){const f=l||c?s:null;if(this.intersectsTriangle(o,f))return(l||c)&&(l&&f.getCenter(l),c&&f.getCenter(c)),0;let a=1/0;for(let u=0;u<3;u++){let p;const d=e[u],b=o[d];this.closestPointToPoint(b,n),p=b.distanceToSquared(n),p<a&&(a=p,l&&l.copy(n),c&&c.copy(b));const w=this[d];o.closestPointToPoint(w,n),p=w.distanceToSquared(n),p<a&&(a=p,l&&l.copy(w),c&&c.copy(n))}for(let u=0;u<3;u++){const p=e[u],d=e[(u+1)%3];s.set(this[p],this[d]);for(let b=0;b<3;b++){const w=e[b],A=e[(b+1)%3];i.set(o[w],o[A]),Et(s,i,n,t);const y=n.distanceToSquared(t);y<a&&(a=y,l&&l.copy(n),c&&c.copy(t))}}return Math.sqrt(a)}}();class N extends Y{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new gt,this.invMatrix=new gt,this.points=new Array(8).fill().map(()=>new F),this.satAxes=new Array(3).fill().map(()=>new F),this.satBounds=new Array(3).fill().map(()=>new q),this.alignedSatBounds=new Array(3).fill().map(()=>new q),this.needsUpdate=!1}set(t,e,s){super.set(t,e),this.matrix=s,this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}N.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let f=0;f<=1;f++)for(let a=0;a<=1;a++)for(let u=0;u<=1;u++){const p=1*f|2*a|4*u,d=i[p];d.x=f?s.x:e.x,d.y=a?s.y:e.y,d.z=u?s.z:e.z,d.applyMatrix4(t)}const r=this.satBounds,o=this.satAxes,l=i[0];for(let f=0;f<3;f++){const a=o[f],u=r[f],p=1<<f,d=i[p];a.subVectors(l,d),u.setFromPoints(a,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();N.prototype.intersectsBox=function(){const n=new q;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,r=this.satBounds,o=this.satAxes,l=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,l[0].isSeparated(n)||(n.min=s.y,n.max=i.y,l[1].isSeparated(n))||(n.min=s.z,n.max=i.z,l[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const f=o[c],a=r[c];if(n.setFromBox(f,e),a.isSeparated(n))return!1}return!0}}();N.prototype.intersectsTriangle=function(){const n=new k,t=new Array(3),e=new q,s=new q,i=new F;return function(o){this.needsUpdate&&this.update(),o.isSeparatingAxisTriangle?o.needsUpdate&&o.update():(n.copy(o),n.update(),o=n);const l=this.satBounds,c=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let p=0;p<3;p++){const d=l[p],b=c[p];if(e.setFromPoints(b,t),d.isSeparated(e))return!1}const f=o.satBounds,a=o.satAxes,u=this.points;for(let p=0;p<3;p++){const d=f[p],b=a[p];if(e.setFromPoints(b,u),d.isSeparated(e))return!1}for(let p=0;p<3;p++){const d=c[p];for(let b=0;b<4;b++){const w=a[b];if(i.crossVectors(d,w),e.setFromPoints(i,t),s.setFromPoints(i,u),e.isSeparated(s))return!1}}return!0}}();N.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();N.prototype.distanceToPoint=function(){const n=new F;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();N.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new O),e=new Array(12).fill().map(()=>new O),s=new F,i=new F;return function(o,l=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||f)&&(o.getCenter(i),this.closestPointToPoint(i,s),o.closestPointToPoint(s,i),c&&c.copy(s),f&&f.copy(i)),0;const a=l*l,u=o.min,p=o.max,d=this.points;let b=1/0;for(let A=0;A<8;A++){const y=d[A];i.copy(y).clamp(u,p);const x=y.distanceToSquared(i);if(x<b&&(b=x,c&&c.copy(y),f&&f.copy(i),x<a))return Math.sqrt(x)}let w=0;for(let A=0;A<3;A++)for(let y=0;y<=1;y++)for(let x=0;x<=1;x++){const h=(A+1)%3,m=(A+2)%3,g=y<<h|x<<m,P=1<<A|y<<h|x<<m,M=d[g],B=d[P];t[w].set(M,B);const S=n[A],v=n[h],I=n[m],C=e[w],L=C.start,V=C.end;L[S]=u[S],L[v]=y?u[v]:p[v],L[I]=x?u[I]:p[v],V[S]=p[S],V[v]=y?u[v]:p[v],V[I]=x?u[I]:p[v],w++}for(let A=0;A<=1;A++)for(let y=0;y<=1;y++)for(let x=0;x<=1;x++){i.x=A?p.x:u.x,i.y=y?p.y:u.y,i.z=x?p.z:u.z,this.closestPointToPoint(i,s);const h=i.distanceToSquared(s);if(h<b&&(b=h,c&&c.copy(s),f&&f.copy(i),h<a))return Math.sqrt(h)}for(let A=0;A<12;A++){const y=t[A];for(let x=0;x<12;x++){const h=e[x];Et(y,h,s,i);const m=s.distanceToSquared(i);if(m<b&&(b=m,c&&c.copy(s),f&&f.copy(i),m<a))return Math.sqrt(m)}}return Math.sqrt(b)}}();const ht=new F,yt=new F,xt=new F,Yt=new at,$t=new at,Zt=new at,Jt=new F;function Oe(n,t,e,s,i,r){let o;return r===Be?o=n.intersectTriangle(s,e,t,!0,i):o=n.intersectTriangle(t,e,s,r!==Me,i),o===null?null:{distance:n.origin.distanceTo(i),point:i.clone()}}function ke(n,t,e,s,i,r,o){ht.fromBufferAttribute(t,s),yt.fromBufferAttribute(t,i),xt.fromBufferAttribute(t,r);const l=Oe(n,ht,yt,xt,Jt,o);if(l){e&&(Yt.fromBufferAttribute(e,s),$t.fromBufferAttribute(e,i),Zt.fromBufferAttribute(e,r),l.uv=Ct.getUV(Jt,ht,yt,xt,Yt,$t,Zt,new at));const c={a:s,b:i,c:r,normal:new F,materialIndex:0};Ct.getNormal(ht,yt,xt,c.normal),l.face=c,l.faceIndex=s}return l}function ae(n,t,e,s,i){const r=s*3,o=n.index.getX(r),l=n.index.getX(r+1),c=n.index.getX(r+2),f=ke(e,n.attributes.position,n.attributes.uv,o,l,c,t);return f?(f.faceIndex=s,i&&i.push(f),f):null}function je(n,t,e,s,i,r){for(let o=s,l=s+i;o<l;o++)ae(n,t,e,o,r)}function Xe(n,t,e,s,i){let r=1/0,o=null;for(let l=s,c=s+i;l<c;l++){const f=ae(n,t,e,l);f&&f.distance<r&&(o=f,r=f.distance)}return o}function le(n,t,e){return n===null||(n.point.applyMatrix4(t.matrixWorld),n.distance=n.point.distanceTo(e.ray.origin),n.object=t,n.distance<e.near||n.distance>e.far)?null:n}function R(n,t,e,s){const i=n.a,r=n.b,o=n.c;let l=t,c=t+1,f=t+2;e&&(l=e.getX(t),c=e.getX(t+1),f=e.getX(t+2)),i.x=s.getX(l),i.y=s.getY(l),i.z=s.getZ(l),r.x=s.getX(c),r.y=s.getY(c),r.z=s.getZ(c),o.x=s.getX(f),o.y=s.getY(f),o.z=s.getZ(f)}function Kt(n,t,e,s,i,r,o){const l=e.index,c=e.attributes.position;for(let f=n,a=t+n;f<a;f++)if(R(o,f*3,l,c),o.needsUpdate=!0,s(o,f,i,r))return!0;return!1}class fe{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function X(n,t){return t[n+15]===65535}function Q(n,t){return t[n+6]}function ot(n,t){return t[n+14]}function rt(n){return n+8}function ct(n,t){return t[n+6]}function We(n,t){return t[n+7]}const K=new Y,Tt=new F,Ge=["x","y","z"];function zt(n,t,e,s,i){let r=n*2,o=tt,l=W,c=G;if(X(r,l)){const a=Q(n,c),u=ot(r,l);je(t,e,s,a,u,i)}else{const a=rt(n);Bt(a,o,s,Tt)&&zt(a,t,e,s,i);const u=ct(n,c);Bt(u,o,s,Tt)&&zt(u,t,e,s,i)}}function Lt(n,t,e,s){let i=n*2,r=tt,o=W,l=G;if(X(i,o)){const f=Q(n,l),a=ot(i,o);return Xe(t,e,s,f,a)}else{const f=We(n,l),a=Ge[f],p=s.direction[a]>=0;let d,b;p?(d=rt(n),b=ct(n,l)):(d=ct(n,l),b=rt(n));const A=Bt(d,r,s,Tt)?Lt(d,t,e,s):null;if(A){const h=A.point[a];if(p?h<=r[b+f]:h>=r[b+f+3])return A}const x=Bt(b,r,s,Tt)?Lt(b,t,e,s):null;return A&&x?A.distance<=x.distance?A:x:A||x||null}}const Ye=function(){let n,t;const e=[],s=new fe(()=>new Y);return function(...o){n=s.getPrimitive(),t=s.getPrimitive(),e.push(n,t);const l=i(...o);s.releasePrimitive(n),s.releasePrimitive(t),e.pop(),e.pop();const c=e.length;return c>0&&(t=e[c-1],n=e[c-2]),l};function i(r,o,l,c,f=null,a=0,u=0){function p(h){let m=h*2,g=W,P=G;for(;!X(m,g);)h=rt(h),m=h*2;return Q(h,P)}function d(h){let m=h*2,g=W,P=G;for(;!X(m,g);)h=ct(h,P),m=h*2;return Q(h,P)+ot(m,g)}let b=r*2,w=tt,A=W,y=G;if(X(b,A)){const h=Q(r,y),m=ot(b,A);return _(r,w,n),c(h,m,!1,u,a+r,n)}else{const h=rt(r),m=ct(r,y);let g=h,P=m,M,B,T,S;if(f&&(T=n,S=t,_(g,w,T),_(P,w,S),M=f(T),B=f(S),B<M)){g=m,P=h;const E=M;M=B,B=E,T=S}T||(T=n,_(g,w,T));const v=X(g*2,A),I=l(T,v,M,u+1,a+g);let C;if(I===kt){const E=p(g),Z=d(g)-E;C=c(E,Z,!0,u+1,a+g,T)}else C=I&&i(g,o,l,c,f,a,u+1);if(C)return!0;S=t,_(P,w,S);const L=X(P*2,A),V=l(S,L,B,u+1,a+P);let U;if(V===kt){const E=p(P),Z=d(P)-E;U=c(E,Z,!0,u+1,a+P,S)}else U=V&&i(P,o,l,c,f,a,u+1);return!!U}}}(),$e=function(){const n=new k,t=new k,e=new gt,s=new N,i=new N;return function r(o,l,c,f,a=null){let u=o*2,p=tt,d=W,b=G;if(a===null&&(c.boundingBox||c.computeBoundingBox(),s.set(c.boundingBox.min,c.boundingBox.max,f),a=s),X(u,d)){const A=l,y=A.index,x=A.attributes.position,h=c.index,m=c.attributes.position,g=Q(o,b),P=ot(u,d);if(e.copy(f).invert(),c.boundsTree)return _(o,p,i),i.matrix.copy(e),i.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:B=>i.intersectsBox(B),intersectsTriangle:B=>{B.a.applyMatrix4(f),B.b.applyMatrix4(f),B.c.applyMatrix4(f),B.needsUpdate=!0;for(let T=g*3,S=(P+g)*3;T<S;T+=3)if(R(t,T,y,x),t.needsUpdate=!0,B.intersectsTriangle(t))return!0;return!1}});for(let M=g*3,B=P+g*3;M<B;M+=3){R(n,M,y,x),n.a.applyMatrix4(e),n.b.applyMatrix4(e),n.c.applyMatrix4(e),n.needsUpdate=!0;for(let T=0,S=h.count;T<S;T+=3)if(R(t,T,h,m),t.needsUpdate=!0,n.intersectsTriangle(t))return!0}}else{const A=o+8,y=b[o+6];return _(A,p,K),!!(a.intersectsBox(K)&&r(A,l,c,f,a)||(_(y,p,K),a.intersectsBox(K)&&r(y,l,c,f,a)))}}}();function Bt(n,t,e,s){return _(n,t,K),e.intersectBox(K,s)}const Ut=[];let bt,tt,W,G;function it(n){bt&&Ut.push(bt),bt=n,tt=new Float32Array(n),W=new Uint16Array(n),G=new Uint32Array(n)}function mt(){bt=null,tt=null,W=null,G=null,Ut.length&&it(Ut.pop())}const vt=Symbol("skip tree generation"),It=new Y,Ft=new Y,J=new gt,$=new N,nt=new N,st=new F,wt=new F,Ze=new F,Je=new F,Ke=new F,Qt=new Y,D=new fe(()=>new k);class z{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),z.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e=ft({cloneBuffers:!0},e);const s=t.geometry,i=t._roots,r=s.getIndex();let o;return e.cloneBuffers?o={roots:i.map(l=>l.slice()),index:r.array.slice()}:o={roots:i,index:r.array},o}static deserialize(t,e,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),z.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s=ft({setIndex:!0},s);const{index:i,roots:r}=t,o=new z(e,Ht(ft({},s),{[vt]:!0}));if(o._roots=r,s.setIndex){const l=e.getIndex();if(l===null){const c=new Pt(t.index,1,!1);e.setIndex(c)}else l.array!==i&&(l.array.set(i),l.needsUpdate=!0)}return o}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:ce,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[vt]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer=="undefined")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[vt]||(this._roots=qe(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Y))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,s=e.index.array,i=e.attributes.position,r=i.array,o=i.offset||0;let l=3;i.isInterleavedBufferAttribute&&(l=i.data.stride);let c,f,a,u,p=0;const d=this._roots;for(let w=0,A=d.length;w<A;w++)c=d[w],f=new Uint32Array(c),a=new Uint16Array(c),u=new Float32Array(c),b(0,p),p+=c.byteLength;function b(w,A,y=!1){const x=w*2;if(a[x+15]===Vt){const m=f[w+6],g=a[x+14];let P=1/0,M=1/0,B=1/0,T=-1/0,S=-1/0,v=-1/0;for(let I=3*m,C=3*(m+g);I<C;I++){const L=s[I]*l+o,V=r[L+0],U=r[L+1],E=r[L+2];V<P&&(P=V),V>T&&(T=V),U<M&&(M=U),U>S&&(S=U),E<B&&(B=E),E>v&&(v=E)}return u[w+0]!==P||u[w+1]!==M||u[w+2]!==B||u[w+3]!==T||u[w+4]!==S||u[w+5]!==v?(u[w+0]=P,u[w+1]=M,u[w+2]=B,u[w+3]=T,u[w+4]=S,u[w+5]=v,!0):!1}else{const m=w+8,g=f[w+6],P=m+A,M=g+A;let B=y,T=!1,S=!1;t?B||(T=t.has(P),S=t.has(M),B=!T&&!S):(T=!0,S=!0);const v=B||T,I=B||S;let C=!1;v&&(C=b(m,A,B));let L=!1;I&&(L=b(g,A,B));const V=C||L;if(V)for(let U=0;U<3;U++){const E=m+U,lt=g+U,Z=u[E],_t=u[E+3],Dt=u[lt],Rt=u[lt+3];u[w+U]=Z<Dt?Z:Dt,u[w+U+3]=_t>Rt?_t:Rt}return V}}}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),r=new Uint16Array(s);o(0);function o(l,c=0){const f=l*2,a=r[f+15]===Vt;if(a){const u=i[l+6],p=r[f+14];t(c,a,new Float32Array(s,l*4,6),u,p)}else{const u=l+At/4,p=i[l+6],d=i[l+7];t(c,a,new Float32Array(s,l*4,6),d)||(o(u,c+1),o(p,c+1))}}}raycast(t,e=Ot){const s=this._roots,i=this.geometry,r=[],o=e.isMaterial,l=Array.isArray(e),c=i.groups,f=o?e.side:e;for(let a=0,u=s.length;a<u;a++){const p=l?e[c[a].materialIndex].side:f,d=r.length;if(it(s[a]),zt(0,i,p,t,r),mt(),l){const b=c[a].materialIndex;for(let w=d,A=r.length;w<A;w++)r[w].face.materialIndex=b}}return r}raycastFirst(t,e=Ot){const s=this._roots,i=this.geometry,r=e.isMaterial,o=Array.isArray(e);let l=null;const c=i.groups,f=r?e.side:e;for(let a=0,u=s.length;a<u;a++){const p=o?e[c[a].materialIndex].side:f;it(s[a]);const d=Lt(0,i,p,t);mt(),d!=null&&(l==null||d.distance<l.distance)&&(l=d,o&&(d.face.materialIndex=c[a].materialIndex))}return l}intersectsGeometry(t,e){const s=this.geometry;let i=!1;for(const r of this._roots)if(it(r),i=$e(0,s,t,e),mt(),i)break;return i}shapecast(t,e,s){const i=this.geometry;if(t instanceof Function){if(e){const p=e;e=(d,b,w,A)=>{const y=b*3;return p(d,y,y+1,y+2,w,A)}}t={boundsTraverseOrder:s,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=D.getPrimitive();let{boundsTraverseOrder:o,intersectsBounds:l,intersectsRange:c,intersectsTriangle:f}=t;if(c&&f){const p=c;c=(d,b,w,A,y)=>p(d,b,w,A,y)?!0:Kt(d,b,i,f,w,A,r)}else c||(f?c=(p,d,b,w)=>Kt(p,d,i,f,b,w,r):c=(p,d,b)=>b);let a=!1,u=0;for(const p of this._roots){if(it(p),a=Ye(0,i,l,c,o,u),mt(),a)break;u+=p.byteLength}return D.releasePrimitive(r),a}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:r}=s;const o=this.geometry.index,l=this.geometry.attributes.position,c=t.geometry.index,f=t.geometry.attributes.position;J.copy(e).invert();const a=D.getPrimitive(),u=D.getPrimitive();if(r){let d=function(b,w,A,y,x,h,m,g){for(let P=A,M=A+y;P<M;P++){R(u,P*3,c,f),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let B=b,T=b+w;B<T;B++)if(R(a,B*3,o,l),a.needsUpdate=!0,r(a,u,B,P,x,h,m,g))return!0}return!1};if(i){const b=i;i=function(w,A,y,x,h,m,g,P){return b(w,A,y,x,h,m,g,P)?!0:d(w,A,y,x,h,m,g,P)}}else i=d}this.getBoundingBox(Ft),Ft.applyMatrix4(e);const p=this.shapecast({intersectsBounds:d=>Ft.intersectsBox(d),intersectsRange:(d,b,w,A,y,x)=>(It.copy(x),It.applyMatrix4(J),t.shapecast({intersectsBounds:h=>It.intersectsBox(h),intersectsRange:(h,m,g,P,M)=>i(d,b,h,m,A,y,P,M)}))});return D.releasePrimitive(a),D.releasePrimitive(u),p}intersectsBox(t,e){return $.set(t.min,t.max,e),$.needsUpdate=!0,this.shapecast({intersectsBounds:s=>$.intersectsBox(s),intersectsTriangle:s=>$.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},r=0,o=1/0){t.boundingBox||t.computeBoundingBox(),$.set(t.boundingBox.min,t.boundingBox.max,e),$.needsUpdate=!0;const l=this.geometry,c=l.attributes.position,f=l.index,a=t.attributes.position,u=t.index,p=D.getPrimitive(),d=D.getPrimitive();let b=wt,w=Ze,A=null,y=null;i&&(A=Je,y=Ke);let x=1/0,h=null,m=null;return J.copy(e).invert(),nt.matrix.copy(J),this.shapecast({boundsTraverseOrder:g=>$.distanceToBox(g,Math.min(x,o)),intersectsBounds:(g,P,M)=>M<x&&M<o?(P&&(nt.min.copy(g.min),nt.max.copy(g.max),nt.needsUpdate=!0),!0):!1,intersectsRange:(g,P)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:M=>nt.distanceToBox(M,Math.min(x,o)),intersectsBounds:(M,B,T)=>T<x&&T<o,intersectsRange:(M,B)=>{for(let T=M*3,S=(M+B)*3;T<S;T+=3){R(d,T,u,a),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let v=g*3,I=(g+P)*3;v<I;v+=3){R(p,v,f,c),p.needsUpdate=!0;const C=p.distanceToTriangle(d,b,A);if(C<x&&(w.copy(b),y&&y.copy(A),x=C,h=v/3,m=T/3),C<r)return!0}}}});{const M=u?u.count:a.count;for(let B=0,T=M;B<T;B+=3){R(d,B,u,a),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let S=g*3,v=(g+P)*3;S<v;S+=3){R(p,S,f,c),p.needsUpdate=!0;const I=p.distanceToTriangle(d,b,A);if(I<x&&(w.copy(b),y&&y.copy(A),x=I,h=S/3,m=B/3),I<r)return!0}}}}}),D.releasePrimitive(p),D.releasePrimitive(d),x===1/0?null:(s.point?s.point.copy(w):s.point=w.clone(),s.distance=x,s.faceIndex=h,i&&(i.point?i.point.copy(y):i.point=y.clone(),i.point.applyMatrix4(J),w.applyMatrix4(J),i.distance=w.sub(i.point).length(),i.faceIndex=m),s)}closestPointToPoint(t,e={},s=0,i=1/0){const r=s*s,o=i*i;let l=1/0,c=null;if(this.shapecast({boundsTraverseOrder:a=>(st.copy(t).clamp(a.min,a.max),st.distanceToSquared(t)),intersectsBounds:(a,u,p)=>p<l&&p<o,intersectsTriangle:(a,u)=>{a.closestPointToPoint(t,st);const p=t.distanceToSquared(st);return p<l&&(wt.copy(st),l=p,c=u),p<r}}),l===1/0)return null;const f=Math.sqrt(l);return e.point?e.point.copy(wt):e.point=wt.clone(),e.distance=f,e.faceIndex=c,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{_(0,new Float32Array(s),Qt),t.union(Qt)}),t}}const te=z.prototype.raycast;z.prototype.raycast=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[t,e,s,i]=n;return te.call(this,s,t.material).forEach(o=>{o=le(o,t,e),o&&i.push(o)}),i}else return te.apply(this,n)};const ee=z.prototype.raycastFirst;z.prototype.raycastFirst=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[t,e,s]=n;return le(ee.call(this,s,t.material),t,e)}else return ee.apply(this,n)};const ne=z.prototype.closestPointToPoint;z.prototype.closestPointToPoint=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),n.unshift();const t=n[1],e={};return n[1]=e,ne.apply(this,n),t&&t.copy(e.point),e.distance}else return ne.apply(this,n)};const se=z.prototype.closestPointToGeometry;z.prototype.closestPointToGeometry=function(...n){const t=n[2],e=n[3];if(t&&t.isVector3||e&&e.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const s={},i={},r=n[1];return n[2]=s,n[3]=i,se.apply(this,n),t&&t.copy(s.point),e&&e.copy(i.point).applyMatrix4(r),s.distance}else return se.apply(this,n)};const ie=z.prototype.refit;z.prototype.refit=function(...n){const t=n[0],e=n[1];if(e&&(e instanceof Set||Array.isArray(e))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const s=new Set;e.forEach(i=>s.add(i)),t&&t.forEach(i=>s.add(i)),ie.call(this,s)}else ie.apply(this,n)};["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach(n=>{const t=z.prototype[n];z.prototype[n]=function(...e){return(e[0]===null||e[0].isMesh)&&(e.shift(),console.warn(`MeshBVH: The function signature for "${n}" has changed and no longer takes Mesh. See docs for new signature.`)),t.apply(this,e)}});const oe=new Y;class Qe extends Pe{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,s=10,i=0){super(),this.material=e,this.geometry=new Te,this.name="MeshBVHRootVisualizer",this.depth=s,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=i}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,s=this._group;if(t.dispose(),this.visible=!1,e){const i=this.depth-1,r=this.displayParents;let o=0;e.traverse((p,d)=>{if(p===i||d)return o++,!0;r&&o++},s);let l=0;const c=new Float32Array(8*3*o);e.traverse((p,d,b)=>{const w=p===i||d;if(w||r){_(0,b,oe);const{min:A,max:y}=oe;for(let x=-1;x<=1;x+=2){const h=x<0?A.x:y.x;for(let m=-1;m<=1;m+=2){const g=m<0?A.y:y.y;for(let P=-1;P<=1;P+=2){const M=P<0?A.z:y.z;c[l+0]=h,c[l+1]=g,c[l+2]=M,l+=3}}}return w}},s);let f,a;this.displayEdges?a=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):a=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),c.length>65535?f=new Uint32Array(a.length*o):f=new Uint16Array(a.length*o);const u=a.length;for(let p=0;p<o;p++){const d=p*8,b=p*u;for(let w=0;w<u;w++)f[b+w]=d+a[w]}t.setIndex(new Pt(f,1,!1)),t.setAttribute("position",new Pt(c,3,!1)),this.visible=!0}}}class ue extends me{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const s=new we({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),i=new Ae({color:65416,transparent:!0,opacity:.3,depthWrite:!1});i.color=s.color,this.edgeMaterial=s,this.meshMaterial=i,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let s=0;s<e;s++){if(s>=this._roots.length){const r=new Qe(this.mesh,this.edgeMaterial,this.depth,s);this.add(r),this._roots.push(r)}const i=this._roots[s];i.depth=this.depth,i.mesh=this.mesh,i.displayParents=this.displayParents,i.displayEdges=this.displayEdges,i.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,i.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new ue(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].geometry.dispose()}}be.prototype.raycast;const tn=new WeakMap;var sn=n=>{n.outerObject3d.updateMatrixWorld(!0);const t=[];n.outerObject3d.traverse(s=>{if(!s.geometry||s===n.object3d&&!(n instanceof Se))return;const i=s.geometry.clone();i.applyMatrix4(s.matrixWorld),t.push(i),i.dispose()});const e=[];for(const s of t){const i=s.boundsTree=new z(s);e.push(i),tn.set(i,n)}return[e,t]};export{ue as M,tn as b,sn as c};
