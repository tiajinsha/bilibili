import{$ as P,bj as O,bk as V,a7 as H,a0 as R,bl as z,a2 as G,a1 as U,a3 as w,o as j,a4 as E,a5 as T,bb as W,bm as _,V as N}from"./index.326876e1.js";import{g as k}from"./useBVHMap.a349d17f.js";import{b as F}from"./computeBVH.7b6caef1.js";const f=new Set,I=()=>new WeakSet;P(function(){if(H())return;const s=k();if(!s.length)return;const c=O(),y=V(),l=.02,A=R(()=>{z.clear();for(const t of f){const a=t.bvhVelocity,o=t.outerObject3d,m=t.bvhHalfHeight,n=t.bvhRadius;a.y+=t.bvhOnGround?0:l*-c;const{position:r}=t.physicsUpdate;t.physicsUpdate={},r&&(r.x&&(a.x=0),r.y&&(a.y=0),r.z&&(a.z=0)),o.position.addScaledVector(a,l),o.updateMatrixWorld();const{start:i,end:h}=w;h.copy(i.copy(o.position));const v=Math.max(m-n,0);h.y+=v,i.y-=v;const B=i.clone();G.setFromCenterAndSize(o.position,U.set(n*2,m*2,n*2));const g=E,M=T;let d=0,p,S=!1,u;for(const x of s)u=F.get(x),x.shapecast({intersectsBounds:b=>b.intersectsBox(G),intersectsTriangle:b=>{d=b.closestPointToSegment(w,g,M),d<n&&(S=!0,p=M.sub(g).normalize().multiplyScalar(n-d),i.add(p),h.add(p))}});S&&u&&j(z,t,I).add(u);const e=i.sub(B);t.bvhOnGround=e.y>Math.abs(l*a.y*.25),y&&t.bvhOnGround&&Math.abs(e.y/(e.x+e.z+Number.EPSILON))<y&&(t.bvhOnGround=!1);const C=Math.max(0,e.length()-1e-5);e.normalize().multiplyScalar(C),o.position.add(e),t.bvhOnGround?a.set(0,0,0):(e.normalize(),a.addScaledVector(e,-e.dot(a)))}});return()=>{A.cancel()}},[k,O,V,H]);function D(s){if(s.done)return;W.attach(this.outerObject3d),this.width=this.depth=Math.min(this.width,this.depth),this.physicsUpdate={};const c=_(this).multiplyScalar(.5);this.bvhHalfHeight=Math.max(c.y,.5),this.bvhRadius=Math.max(c.x,.5),this.bvhVelocity=new N,f.add(this),s.then(()=>{f.delete(this),this.physicsUpdate=void 0})}export{D as default};
